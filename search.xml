<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[进程同步问题-读者写者]]></title>
      <url>%2F2017%2F05%2F02%2Fprocess-reader-writer%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第二弹：读者写者问题 ###问题分析1.允许多个读进程进行读操作2.不允许读和写同时进行操作3.不允许多个读进程进行写操作读者和写者问题其实可以分为三种：读者优先 写者优先 公平竞争读者优先和公平竞争之间只差了一个信号量来对读写进程进行平等访问。读者优先可能造成写进程饿死，公平竞争的结果则是所有读进程结束后写进程才允许进行。而对与写者优先来说，读操作进行前需让出资源给写进程。 ###代码实现ps.condition.acquire() 与 condition.release() 间的通信尤为重要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import threadingfrom threading import Thread,Conditionimport timeimport randomglobal readcount,write,read,qc# 读者进程数readernum = 5# 读者数信号量计数readcount=0# 读者写者互斥访问write=0# 读者信号量read=0# 读者写者公平竞争信号量qc = 0rmutex=Condition()#readcount访问互斥wmutex=Condition()#读写互斥queue=Condition() #公平竞争class Reader(threading.Thread): """读者进程""" def __init__(self, num ): threading.Thread.__init__(self) self.num=num print('reader %s'%(num)) def run(self): global readcount,write,read,qc while True: queue.acquire() if qc==1: queue.wait() qc=1 rmutex.acquire() if read==1: rmutex.wait() read=1 if readcount==0 : wmutex.acquire() if write!=0: print('Reader want to read but writer is writing now!') wmutex.wait() print('Reader is notified by writer') wmutex.release() else: wmutex.release() readcount+=1 print("reader%s %s++"%(self.num,readcount)) read=0 rmutex.notify() rmutex.release() qc=0 queue.notify() queue.release() print("Reader%s is reading now!"%(self.num)) time.sleep(random.randint(1,5)) rmutex.acquire() if read==1: rmutex.wait() read=1 readcount-=1 print("reader%s %s--"%(self.num,readcount)) read=0 if readcount==0: wmutex.acquire() if(write==0): wmutex.notify() wmutex.release() else: wmutex.release() rmutex.notify() rmutex.release() print("Reader%s has finishied reading!"%(self.num))class Writer(threading.Thread): def run(self): global readcount,write,qc while True: queue.acquire() if qc==1: queue.wait() qc = 1 wmutex.acquire() if readcount!=0: print('Writer want to write but reader is reading now!') wmutex.wait() print("Writer is notified by readers!") write=1 print('Writer is writing now!') time.sleep(5) write=0 wmutex.notify() wmutex.release() qc=0 queue.notify() queue.release() print('Finished writing!')Writer().start()Readers = []# 创建读者5个进程for x in range(1,readernum): Readers.append(Reader(x))for x in Readers: x.start() p.s. 还有三个进程同步问题…持续中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-生产者消费者]]></title>
      <url>%2F2017%2F04%2F23%2Fprocess-consumer-producer%2F</url>
      <content type="text"><![CDATA[操作系统中经典进程同步问题，生产者消费者问题。这里用python是考虑到python可以处理多线程之间的通信问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import threadingimport timeimport randomproduct_max_num = 5product_pool = []class producer(threading.Thread): def __init__(self,cond,name): super(producer, self).__init__() self.cond = cond self.name = name def run(self): queue = range(5) global product_pool while True: self.cond.acquire() if len(product_pool)==product_max_num: print("product pool is full!") self.cond.wait() index = random.choice(queue) print("%s product %s" %(self.name,index)) product_pool.append(index) self.cond.notify() # if len(product_pool)&lt;product_max_num: # index = random.choice(queue) # print("%s product %s" %(self.name,index)) # product_pool.append(index) # self.cond.notify() # else: # print("product pool is full!") # self.cond.wait() self.cond.release() time.sleep(1)class consumer(threading.Thread): def __init__(self,cond,name): super(consumer, self).__init__() self.cond = cond self.name = name def run(self): global product_pool while True: self.cond.acquire() if len(product_pool) == 0: print("product pool is empty!") self.cond.wait() index = product_pool.pop(0) print("%s consume %s" %(self.name,index)) self.cond.notify() # if len(product_pool)&gt;0: # index = product_pool.pop(0) # print("%s consume %s" %(self.name,index)) # self.cond.notify() # else: # print("product pool is empty!") # self.cond.wait() self.cond.release() time.sleep(1)cond = threading.Condition()producer = producer(cond,'producer')consumer = consumer(cond,'consumer')producer.start()consumer.start()producer.join()consumer.join()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax实现图片上传]]></title>
      <url>%2F2017%2F03%2F25%2Fimg-upload%2F</url>
      <content type="text"><![CDATA[写项目的时候需要图片上传功能，这在web开发中也是比较普遍的功能。今天整理出一段时间关于图片上传的知识。一般上传图片的时候都需要图片预览，之后再提交，上传服务器。关于图片预览需要用到html5里的一些知识。 123&lt;!-- file类型的input，绑定uploadImg事件 --&gt;&lt;input type="file" name="上传图片" onchange="uploadImg(this)" &gt;&lt;img src="" id="img"&gt; 个人觉得ajax上传图片用户体验比较好，当然你也可以做成表单提交这里写了两个比较基本的判断，判断是否为图片格式和图片大小（最大为2M）。HTML5定义了FileReader作为文件API的重要成员用于读取文件，实现了图片预览。12345678910111213141516171819202122232425262728293031323334353637383940414243function uploadImg(source)&#123; var name = source.value; var file = source.files[0]; var fd = new FormData(); //正则判断上传文件格式 if(!/\.(gif|jpg|png|jpeg)$/.test(name))&#123; alert('上传的必须要是图片'); source.value=""; return ; &#125; //判断上传文件大小 if(file/1024&gt;2000)&#123; alert('上传的图片必须小于2m'); return ; &#125; //图片预览 if(window.FileReader)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; $('#img').attr('src',e.target.result) &#125; reader.readAsDataURL(file); &#125;else&#123; alert('browser not support!'); return ; &#125; fd.append("upfile",file); //ajax upload $.ajax(&#123; url:url, type:'POST', data:fd, //阻止序列化操作 processData:false, contentType:false, success:function(res)&#123; console.log('ok'); &#125;, error:function(res)&#123; console.log('no'); &#125; &#125;);&#125; 关于后端语言和框架的使用就看个人喜好了。反正我用的是php。上面是一个简单的单个图片上传，可能之后有时间会去做一下多图片的和可拖拽的…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[express下模板引擎共存]]></title>
      <url>%2F2017%2F03%2F24%2Fwindows-nodejs-express%2F</url>
      <content type="text"><![CDATA[最近在学nodejs下的express框架。Express中需要模板引擎来渲染模板文件，也就是我们平常说的html文件。在express工程中默认是jade视图引擎，但我想用html来写我的视图文件，需要ejs模板引擎，那如何让两种模板引擎共同存在。 cmd安装nodejs模块1npm install consolidate 1npm install express-hogan 在express的app.js中设置模板引擎1234567var engines = require('consolidate');app.engine('haml', engines.haml);app.engine('html', engines.hogan);app.set('view engine', 'jade');app.set('view engine', 'html'); 完成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello]]></title>
      <url>%2F2017%2F03%2F24%2FHello%2F</url>
      <content type="text"><![CDATA[我的新博客又诞生了，第一次用静态博客感觉不错，以后会update。关于作者:123456789var I = &#123;Name: 致宇哥哥,Age: 21,School: BUCT,Major: CS,Home: Zhejiang,Phone: 13011136566,Email: 857188491@qq.com&#125;]]></content>
    </entry>

    
  
  
</search>
