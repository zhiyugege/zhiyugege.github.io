<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[中缀表达式求值]]></title>
      <url>%2F2017%2F09%2F25%2Fcomplier-work%2F</url>
      <content type="text"><![CDATA[编译原理作业：中缀表达式求值，写优雅的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct BiTreeNode &#123; char key; struct BiTreeNode *leftNode; struct BiTreeNode *rightNode;&#125;;//BiTreeclass BiTree &#123;protected: BiTreeNode *RootNode; int Before_Visit(BiTreeNode *Node);&#125;;int BiTree::Before_Visit(BiTreeNode *Node) &#123; int leftCount, rightCount; BiTreeNode *p = Node; if(p-&gt;leftNode==NULL &amp;&amp; p-&gt;rightNode==NULL) return (p-&gt;key) - '0'; if(p-&gt;leftNode != NULL) leftCount = Before_Visit(p-&gt;leftNode); if(p-&gt;rightNode != NULL) rightCount = Before_Visit(p-&gt;rightNode); if(p-&gt;key=='+') return leftCount + rightCount; if(p-&gt;key=='-') return leftCount - rightCount; if(p-&gt;key=='*') return leftCount * rightCount; if(p-&gt;key=='/') return leftCount / rightCount;&#125;//Calculator private extends BiTreeclass Calculator : private BiTree&#123;private : string expression;public : void _constructor(); BiTreeNode * main_cal(int ex_start,int ex_end); int get_tag(int ex_start, int ex_end);&#125;;void Calculator::_constructor()&#123; string input; cout &lt;&lt; "please input expression string:" &lt;&lt; endl; cin &gt;&gt; input; expression = input; int ex_length = input.length(); RootNode = main_cal(0, ex_length-1); cout &lt;&lt; Before_Visit(RootNode);&#125;//build BiTreeBiTreeNode *Calculator::main_cal(int ex_start,int ex_end) &#123; BiTreeNode *p = new BiTreeNode; if(ex_start == ex_end) &#123; p-&gt;key = expression[ex_start]; p-&gt;leftNode = NULL; p-&gt;rightNode = NULL; &#125; else &#123; if(expression[ex_start]=='(' &amp;&amp; expression[ex_end]==')') &#123; ex_start += 1; ex_end -= 1; &#125; get_tag(ex_start, ex_end); p-&gt;key = expression[index]; p-&gt;leftNode = main_cal(ex_start, index-1); p-&gt;rightNode = main_cal(index+1, ex_end); &#125; return p;&#125;//find every root node keyint Calculator::get_tag(int ex_start, int ex_end) &#123; string input = expression; int brackets_exit = 0, plus_minus_exit = 0, tag; for(int i=ex_start; i&lt;ex_end; i++) &#123; if((input[i]=='+'|| input[i]=='-') &amp;&amp; brackets_exit==0) &#123; plus_minus_exit = 1; tag = i; &#125; if ((input[i]=='*' || input[i]=='/') &amp;&amp; plus_minus_exit==0 &amp;&amp; brackets_exit==0) &#123; tag = i; &#125; if(input[i]=='(') brackets_exit++; if(input[i]==')') brackets_exit--; &#125; return tag;&#125;int main() &#123; Calculator CAL; CAL._constructor(); return 0;&#125; END]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[opencv 人脸检测]]></title>
      <url>%2F2017%2F09%2F25%2Fopencv-face%2F</url>
      <content type="text"><![CDATA[opencv 定位人脸 主要的python库 PIL 、cv2 。这里利用opencv已经训练好的模型进行人脸定位，在opencv中以xml的文件格式存储。在人脸定位的时候需要调用对应的xx.xml。 1.获取目标图片并检测人脸位置1234567891011121314151617def selectFace(image_name, xml_url): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier(xml_url) # if img.nidm == 3: grayImg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # else: # grayImg= img faces = face_cascade.detectMultiScale(grayImg, 1.3, 5) result = [] for (x, y, width, height) in faces: result.append((x, y, x+width, y+height)) return result CascadeClassifier()函数导入前面需要的xml文件。 cvtColor()函数降低图片颜色维度。 detectMultiScale()函数参数人脸识别精度，1.2-5范围。 2.截取人脸并保存12345678910111213141516def saveFaces(image_name, xml_url): faces = selectFace(image_name, xml_url) if faces: save_dir = image_name.split('.')[0] + "_faces" os.mkdir(save_dir) count = 0 for (x1, y1, x2, y2) in faces: file_name = os.path.join(save_dir, str(count)+".jpg") Image.open(image_name).crop((x1, y1, x2, y2)).save(file_name) count += 1 else: print("get error") 这里是以原图片文件名创建文件夹，文件夹内以识别到的人脸编号保存人脸图片。 END]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VUE 组件小tips集结]]></title>
      <url>%2F2017%2F09%2F14%2Fvue-component%2F</url>
      <content type="text"><![CDATA[这里是平时使用Vue.js的时候遇到的一些小问题，之后会有补充。 1.同级组件通信使用bus通信机制完成组件间通信 12345678910111213//组件中methods:&#123; page:function() &#123; bus.$emit('funcName', parameter) //开始通信 &#125;&#125;//同级组件created: function() &#123; bus.$on('funcName',function(parameter)&#123; //收到通信 ... &#125;)&#125; 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫-模拟登录-jwgl]]></title>
      <url>%2F2017%2F09%2F14%2Fjwgl-spider%2F</url>
      <content type="text"><![CDATA[这几天在写爬虫，爬学校教务网的课表信息，然后嵌进一个成员管理系统。前后总共花了两三天的时间。大致摸清了教务网新系统的套路。 问题分析获取课表数据的时候，用户一定是在登录状态下，所以生爬课表那个页面的时候是获得不了数据的。第一步就是要模拟用户在客户端登录。然后一顿看source后发现，教务网登录时首先会根据用户第一次登录首页随机生成的那个session，向服务器请求获得对应的加密公钥，然后把密码在客户端加密后，带着session请求登录。登录成功后，就可以根据那个随机的sessioh和headers获得课表数据。之后动态数据加载，访问api这些就很简单。 具体实现这次用到的node包是 superagent，主要功能是模拟客户端请求。1npm install superagent -save 主要用法如下：1234567891011121314151617181920212223242526const req = require('superagent');//get sessionreq.get(this.main_url) //首页url.end((err, res) =&gt; &#123; let public_key = &#123;&#125;; let session = res.headers['set-cookie'][0].substr(0, res.headers['set-cookie'][0].indexOf(';')); this.session = session; &#125;) &#125;)// simulate loginreq.post(this.login_url) //登录api.type('form').send(conf) //登录信息.set(this.login_headers) //设置访问头.set(&#123;'Cookie':session&#125;).redirects(0).end((err, res) =&gt; &#123; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-医生看病问题]]></title>
      <url>%2F2017%2F05%2F06%2Fprocess-doctors%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第五弹：医生看病问题 问题分析问题描述三个病椅，十个等椅，三个医生。病人来了以后，若病椅有空闲，直接去看病；若病椅满，而等椅有空闲，坐在等椅上等待；若病椅和等椅均满，则离开。若无病人看病，医生等待。给出医生和病人的程序，正确实现互斥和同步。 解决思路一开始想的是医生和病椅不是一一对等的关系，后来考虑到实际情况，比如医院里，医生应该和病椅是一一对等的关系，且位置不会发生变化。那么，1.首先就需要一个互斥信号量mutex实现病人对椅子的互斥访问，并且每次访问结束后即坐下后就要释放该信号量，让下一个病人进来找座位。2.每一张病椅对应一个信号量，如果椅子上没有人，医生就休息，病人来了后，通知医生。3.还有就是在等椅上等待看病的病人需要互斥访问病椅。当一个病人就诊完后，通知等待的病人就诊。 代码实现这里用队列存放三张病椅，每次病人选择病椅时get()一个位置，并且通过该位置叫醒医生，看完后，put()释放一个位置，这考虑到病人选择病椅的一个过程。声明的队列是先进先出的队列，即刚看完病的医生到队列最后，让医生休息一会儿。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import threadingimport timeimport queue#椅子的互斥信号量mutex = 1mcond = threading.Condition()pcond = threading.Condition()#病椅pchairs = 3#等椅wchairs = 10class Patient(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num = num def run(self): global mutex,pmutex,pchairs,wchairs mcond.acquire() if mutex==0: mcond.wait() mutex = 0 if wchairs&gt;0 or pchairs&gt;0: if pchairs==0: wchairs = wchairs - 1 mutex = 1 mcond.notify() mcond.release() pcond.acquire() print("Patient%s is waitting" % self.num) pcond.wait() pcond.release() #选择一把病椅 index = dqueue.get() pchairs = pchairs - 1 if mutex==0: mutex = 1 mcond.notify() mcond.release() #通过病椅叫醒医生 doctors[index].acquire() dmutex[index] = 0 doctors[index].notify() doctors[index].release() print("Patient%s is getting cure chosing doctors %s"% (self.num,index)) time.sleep(2) print("Patient%s is finishing cure by doctors %s" % (self.num, index)) dmutex[index] = 1 #释放病椅 dqueue.put(index) pchairs = pchairs + 1 #唤醒正在等待的病人 pcond.acquire() pcond.notify() pcond.release() else: print("no chairs, patient%s leave"%self.num) mutex = 1 mcond.notify() mcond.release()class Doctors(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num = num def run(self): doctors[self.num].acquire() if dmutex[self.num] == 1: print("Doctors%s is waiting..." % self.num) doctors[self.num].wait() print("Doctors%s is working..." % self.num) doctors[self.num].release()#病椅队列dqueue = queue.Queue(maxsize=3)doctors = []dmutex = [1,1,1]#每一张椅子对应一个信号量for x in range(0,3): doctors.append(threading.Condition())#医生进程开始for x in range(0,3): Doctors(x).start() dqueue.put(x)#病人进程开始for x in range(0,15): Patient(x).start()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-理发师问题]]></title>
      <url>%2F2017%2F05%2F05%2Fprocess-barber%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第四弹：理发师问题 问题分析问题描述假设有一个理发店只有一个理发师，一张理发时坐的椅子，若干张普通椅子顾客供等候时坐。没有顾客时，理发师就坐在理发的椅子上睡觉。顾客一到，他不是叫醒理发师，就是离开。如果理发师没有睡觉，而在为别人理发，他就会坐下来等候。如果所有的椅子都坐满了人，最后来的顾客就会离开。 解决方案使用三个信号量（Semaphore）：顾客信号量，理发师信号量，互斥信号量（避免顾客在等理发师，理发师在等顾客，造成死锁）。还需要一个信号量：椅子数量。如果顾客来到时发现没有椅子，就离开，如果发现还有椅子空下就唤醒或等待理发师。 代码实现这里是模拟实现十位顾客先后来理发1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import threadingimport time# 椅子数（包括理发师）chairs = 5# 顾客信号量customers = 0# 理发师信号量barber = 0# 互斥信号量mutex = 1#规定一批接纳顾客customersnum = 10cuscond = threading.Condition()barcond = threading.Condition()mcond = threading.Condition()class Barbers(threading.Thread): def __init__(self,name): threading.Thread.__init__(self) self.name = name def run(self): global chairs,barber,customers,mutex while True: if chairs == 6: print("barber is sleeping") chairs = chairs - 1 customers = 0 barber = 0 mutex = 1 cuscond.acquire() if customers==0: cuscond.wait() print("%s is awaked by customers"%self.name) mcond.acquire() if mutex == 0: mcond.wait() mutex = 0 chairs = chairs + 1 barcond.acquire() barber = 1 barcond.notify() barcond.release() mutex = 1 mcond.notify() mcond.release() cuscond.release()class Customers(threading.Thread): def __init__(self,name): threading.Thread.__init__(self) self.name = name def run(self): global chairs, barber, customers, mutex, customersnum mcond.acquire() if mutex == 0: mcond.wait() mutex = 0 if chairs&gt;0: cuscond.acquire() chairs = chairs - 1 customers = 1 cuscond.notify() cuscond.release() mutex = 1 mcond.notify() mcond.release() if barber==0: barcond.acquire() print("Customers%s is waiting" % (self.name)) barcond.wait() barcond.release() barber = 0 print("Customers%s is cut by barber"%(self.name)) time.sleep(5) chairs = chairs + 1 barber = 1 barcond.acquire() barcond.notify() barcond.release() else: print("chairs is full,%s leave..."%(self.name)) mutex = 1 mcond.notify() mcond.release()Barbers("Barber").start()for x in range(1,customersnum): Customers(x).start()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-哲学家进餐问题]]></title>
      <url>%2F2017%2F05%2F03%2Fprocess-philosophers%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第三弹：哲学家进餐问题 问题分析问题很简单，n个哲学家n支筷子，只有哲学家拿起两支筷子的时候才可以进餐，同样是一个经典的进程同步问题，第n个哲学家的左手边筷子和第n+1个哲学家右手边的筷子是互斥访问的资源。但同样会存在一个问题：死锁。这样的情景很好想。解决死锁问题有很多种的做法1.规定在拿到左侧的筷子后，先检查右面的筷子是否可用。如果不可用，则先放下左侧筷子，等一段时间再重复整个过程。2.最多允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释 放出他所使用过的两支筷子,从而可使更多的哲学家进餐。3.将拿左筷子，与拿右筷子当做一个原子操作（即当左右都拿起的时候才可以进餐）这里选择的是第三种的AND信号量机制。 代码实现之前解决进程间通信问题用的是condition，这里使用的是threading中的Queue方法，之前消费者问题也用过这样的方法。 三种类型queue1.基本FIFO队列–先进先出 class Queue.Queue(maxsize=0)2.LIFO队列–先进后出 class Queue.LifoQueue(maxsize=0)3.优先级队列 class Queue.PriorityQueue(maxsize=0) queue中常用函数queue中封装了一些函数。queue.get() –从队列中取出，如果此时队列为空，阻塞queue.put() –放入队列中，如果此时队列满了，阻塞queue.full() –如果队列满了，返回True,反之Falsequeue.empty() –如果队列为空，返回True,反之False12345678910111213141516171819202122232425262728293031323334353637#AND型信号量解决哲学家进餐问题import threadingimport timeimport queue#哲学家人数同样是筷子数phlioNum = 5class Philosopher(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num = num print("Philosopher %s is thinking"%self.num) def run(self): while True: #and型信号量 if chopsticks[self.num].full() and chopsticks[(self.num+1)%5].full(): chopsticks[self.num].get() chopsticks[(self.num + 1) % 5].get() print("Philosopher %s is eating" % self.num) time.sleep(3) chopsticks[self.num].put(1) chopsticks[(self.num + 1) % 5].put(1)chopsticks = []philosophers = []#声明queue即筷子资源for x in range(0,phlioNum): chopsticks.append(queue.Queue(maxsize=1))for x in chopsticks: x.put(1)for x in range(0,phlioNum): philosophers.append(Philosopher(x))for x in philosophers: x.start() p.s. 持续撸中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-读者写者]]></title>
      <url>%2F2017%2F05%2F02%2Fprocess-reader-writer%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第二弹：读者写者问题 问题分析1.允许多个读进程进行读操作2.不允许读和写同时进行操作3.不允许多个读进程进行写操作读者和写者问题其实可以分为三种：读者优先 写者优先 公平竞争读者优先和公平竞争之间只差了一个信号量来对读写进程进行平等访问。读者优先可能造成写进程饿死，公平竞争的结果则是所有读进程结束后写进程才允许进行。而对与写者优先来说，读操作进行前需让出资源给写进程。 代码实现ps.condition.acquire() 与 condition.release() 间的通信尤为重要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#读者写者公平竞争import threadingfrom threading import Thread,Conditionimport timeimport randomglobal readcount,write,read,qc# 读者进程数readernum = 5# 读者数信号量计数readcount=0# 读者写者互斥访问write=0# 读者信号量read=0# 读者写者公平竞争信号量qc = 0rmutex=Condition()#readcount访问互斥wmutex=Condition()#读写互斥queue=Condition() #公平竞争class Reader(threading.Thread): """读者进程""" def __init__(self, num ): threading.Thread.__init__(self) self.num=num print('reader %s'%(num)) def run(self): global readcount,write,read,qc while True: queue.acquire() if qc==1: queue.wait() qc=1 rmutex.acquire() if read==1: rmutex.wait() read=1 if readcount==0 : wmutex.acquire() if write!=0: print('Reader want to read but writer is writing now!') wmutex.wait() print('Reader is notified by writer') wmutex.release() else: wmutex.release() readcount+=1 print("reader%s %s++"%(self.num,readcount)) read=0 rmutex.notify() rmutex.release() qc=0 queue.notify() queue.release() print("Reader%s is reading now!"%(self.num)) time.sleep(random.randint(1,5)) rmutex.acquire() if read==1: rmutex.wait() read=1 readcount-=1 print("reader%s %s--"%(self.num,readcount)) read=0 if readcount==0: wmutex.acquire() if(write==0): wmutex.notify() wmutex.release() else: wmutex.release() rmutex.notify() rmutex.release() print("Reader%s has finishied reading!"%(self.num))class Writer(threading.Thread): def run(self): global readcount,write,qc while True: queue.acquire() if qc==1: queue.wait() qc = 1 wmutex.acquire() if readcount!=0: print('Writer want to write but reader is reading now!') wmutex.wait() print("Writer is notified by readers!") write=1 print('Writer is writing now!') time.sleep(5) write=0 wmutex.notify() wmutex.release() qc=0 queue.notify() queue.release() print('Finished writing!')Writer().start()Readers = []# 创建读者5个进程for x in range(1,readernum): Readers.append(Reader(x))for x in Readers: x.start() p.s. 还有三个进程同步问题…持续中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-生产者消费者]]></title>
      <url>%2F2017%2F04%2F23%2Fprocess-consumer-producer%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第一弹：生产者消费者问题 问题分析操作系统中经典进程同步问题，生产者消费者问题。producer进程和consumer进程互斥访问资源1.无产品时，consumer阻塞2.产品数量最大时，producer阻塞 代码实现condition模块用于处理进程间通信 condition方法condition.accquire() –获得锁condition.wait() –阻塞等待condition.notify() –通知阻塞进程，退出阻塞condition.release() –释放锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import threadingimport timeimport randomproduct_max_num = 5product_pool = []class producer(threading.Thread): def __init__(self,cond,name): super(producer, self).__init__() self.cond = cond self.name = name def run(self): queue = range(5) global product_pool while True: self.cond.acquire() if len(product_pool)==product_max_num: print("product pool is full!") self.cond.wait() index = random.choice(queue) print("%s product %s" %(self.name,index)) product_pool.append(index) self.cond.notify() # if len(product_pool)&lt;product_max_num: # index = random.choice(queue) # print("%s product %s" %(self.name,index)) # product_pool.append(index) # self.cond.notify() # else: # print("product pool is full!") # self.cond.wait() self.cond.release() time.sleep(1)class consumer(threading.Thread): def __init__(self,cond,name): super(consumer, self).__init__() self.cond = cond self.name = name def run(self): global product_pool while True: self.cond.acquire() if len(product_pool) == 0: print("product pool is empty!") self.cond.wait() index = product_pool.pop(0) print("%s consume %s" %(self.name,index)) self.cond.notify() # if len(product_pool)&gt;0: # index = product_pool.pop(0) # print("%s consume %s" %(self.name,index)) # self.cond.notify() # else: # print("product pool is empty!") # self.cond.wait() self.cond.release() time.sleep(1)cond = threading.Condition()producer = producer(cond,'producer')consumer = consumer(cond,'consumer')producer.start()consumer.start()producer.join()consumer.join()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax实现图片上传]]></title>
      <url>%2F2017%2F03%2F25%2Fimg-upload%2F</url>
      <content type="text"><![CDATA[写项目的时候需要图片上传功能，这在web开发中也是比较普遍的功能。今天整理出一段时间关于图片上传的知识。一般上传图片的时候都需要图片预览，之后再提交，上传服务器。关于图片预览需要用到html5里的一些知识。 123&lt;!-- file类型的input，绑定uploadImg事件 --&gt;&lt;input type="file" name="上传图片" onchange="uploadImg(this)" &gt;&lt;img src="" id="img"&gt; 个人觉得ajax上传图片用户体验比较好，当然你也可以做成表单提交这里写了两个比较基本的判断，判断是否为图片格式和图片大小（最大为2M）。HTML5定义了FileReader作为文件API的重要成员用于读取文件，实现了图片预览。12345678910111213141516171819202122232425262728293031323334353637383940414243function uploadImg(source)&#123; var name = source.value; var file = source.files[0]; var fd = new FormData(); //正则判断上传文件格式 if(!/\.(gif|jpg|png|jpeg)$/.test(name))&#123; alert('上传的必须要是图片'); source.value=""; return ; &#125; //判断上传文件大小 if(file/1024&gt;2000)&#123; alert('上传的图片必须小于2m'); return ; &#125; //图片预览 if(window.FileReader)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; $('#img').attr('src',e.target.result) &#125; reader.readAsDataURL(file); &#125;else&#123; alert('browser not support!'); return ; &#125; fd.append("upfile",file); //ajax upload $.ajax(&#123; url:url, type:'POST', data:fd, //阻止序列化操作 processData:false, contentType:false, success:function(res)&#123; console.log('ok'); &#125;, error:function(res)&#123; console.log('no'); &#125; &#125;);&#125; 关于后端语言和框架的使用就看个人喜好了。反正我用的是php。上面是一个简单的单个图片上传，可能之后有时间会去做一下多图片的和可拖拽的…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[express下模板引擎共存]]></title>
      <url>%2F2017%2F03%2F24%2Fwindows-nodejs-express%2F</url>
      <content type="text"><![CDATA[最近在学nodejs下的express框架。Express中需要模板引擎来渲染模板文件，也就是我们平常说的html文件。在express工程中默认是jade视图引擎，但我想用html来写我的视图文件，需要ejs模板引擎，那如何让两种模板引擎共同存在。 cmd安装nodejs模块1npm install consolidate 1npm install express-hogan 在express的app.js中设置模板引擎1234567var engines = require('consolidate');app.engine('haml', engines.haml);app.engine('html', engines.hogan);app.set('view engine', 'jade');app.set('view engine', 'html'); 完成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello]]></title>
      <url>%2F2017%2F03%2F24%2FHello%2F</url>
      <content type="text"><![CDATA[我的新博客又诞生了，第一次用静态博客感觉不错，以后会update。关于作者:123456789var I = &#123;Name: 致宇哥哥,Age: 21,School: BUCT,Major: CS,Home: Zhejiang,Phone: 13011136566,Email: 857188491@qq.com&#125;]]></content>
    </entry>

    
  
  
</search>
