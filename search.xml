<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[进程同步问题-理发师问题]]></title>
      <url>%2F2017%2F05%2F05%2Fprocess-barber%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第四弹：理发师问题 问题分析问题描述假设有一个理发店只有一个理发师，一张理发时坐的椅子，若干张普通椅子顾客供等候时坐。没有顾客时，理发师就坐在理发的椅子上睡觉。顾客一到，他不是叫醒理发师，就是离开。如果理发师没有睡觉，而在为别人理发，他就会坐下来等候。如果所有的椅子都坐满了人，最后来的顾客就会离开。 解决方案使用三个信号量（Semaphore）：顾客信号量，理发师信号量，互斥信号量（避免顾客在等理发师，理发师在等顾客，造成死锁）。还需要一个信号量：椅子数量。如果顾客来到时发现没有椅子，就离开，如果发现还有椅子空下就唤醒或等待理发师。 代码实现这里是模拟实现十位顾客先后来理发1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import threadingimport time# 椅子数（包括理发师）chairs = 5# 顾客信号量customers = 0# 理发师信号量barber = 0# 互斥信号量mutex = 1#规定一批接纳顾客customersnum = 10cuscond = threading.Condition()barcond = threading.Condition()mcond = threading.Condition()class Barbers(threading.Thread): def __init__(self,name): threading.Thread.__init__(self) self.name = name def run(self): global chairs,barber,customers,mutex while True: if chairs == 6: print("barber is sleeping") chairs = chairs - 1 customers = 0 barber = 0 mutex = 1 cuscond.acquire() if customers==0: cuscond.wait() print("%s is awaked by customers"%self.name) mcond.acquire() if mutex == 0: mcond.wait() mutex = 0 chairs = chairs + 1 barcond.acquire() barber = 1 barcond.notify() barcond.release() mutex = 1 mcond.notify() mcond.release() cuscond.release()class Customers(threading.Thread): def __init__(self,name): threading.Thread.__init__(self) self.name = name def run(self): global chairs, barber, customers, mutex, customersnum mcond.acquire() if mutex == 0: mcond.wait() mutex = 0 if chairs&gt;0: cuscond.acquire() chairs = chairs - 1 customers = 1 cuscond.notify() cuscond.release() mutex = 1 mcond.notify() mcond.release() if barber==0: barcond.acquire() print("Customers%s is waiting" % (self.name)) barcond.wait() barcond.release() barber = 0 print("Customers%s is cut by barber"%(self.name)) time.sleep(5) chairs = chairs + 1 barber = 1 barcond.acquire() barcond.notify() barcond.release() else: print("chairs is full,%s leave..."%(self.name)) mutex = 1 mcond.notify() mcond.release()Barbers("Barber").start()for x in range(1,customersnum): Customers(x).start()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-哲学家进餐问题]]></title>
      <url>%2F2017%2F05%2F03%2Fprocess-philosophers%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第三弹：哲学家进餐问题 问题分析问题很简单，n个哲学家n支筷子，只有哲学家拿起两支筷子的时候才可以进餐，同样是一个经典的进程同步问题，第n个哲学家的左手边筷子和第n+1个哲学家右手边的筷子是互斥访问的资源。但同样会存在一个问题：死锁。这样的情景很好想。解决死锁问题有很多种的做法1.规定在拿到左侧的筷子后，先检查右面的筷子是否可用。如果不可用，则先放下左侧筷子，等一段时间再重复整个过程。2.最多允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释 放出他所使用过的两支筷子,从而可使更多的哲学家进餐。3.将拿左筷子，与拿右筷子当做一个原子操作（即当左右都拿起的时候才可以进餐）这里选择的是第三种的AND信号量机制。 代码实现之前解决进程间通信问题用的是condition，这里使用的是threading中的Queue方法，之前消费者问题也用过这样的方法。 三种类型queue1.基本FIFO队列–先进先出 class Queue.Queue(maxsize=0)2.LIFO队列–先进后出 class Queue.LifoQueue(maxsize=0)3.优先级队列 class Queue.PriorityQueue(maxsize=0) queue中常用函数queue中封装了一些函数。queue.get() –从队列中取出，如果此时队列为空，阻塞queue.put() –放入队列中，如果此时队列满了，阻塞queue.full() –如果队列满了，返回True,反之Falsequeue.empty() –如果队列为空，返回True,反之False12345678910111213141516171819202122232425262728293031323334353637#AND型信号量解决哲学家进餐问题import threadingimport timeimport queue#哲学家人数同样是筷子数phlioNum = 5class Philosopher(threading.Thread): def __init__(self,num): threading.Thread.__init__(self) self.num = num print("Philosopher %s is thinking"%self.num) def run(self): while True: #and型信号量 if chopsticks[self.num].full() and chopsticks[(self.num+1)%5].full(): chopsticks[self.num].get() chopsticks[(self.num + 1) % 5].get() print("Philosopher %s is eating" % self.num) time.sleep(3) chopsticks[self.num].put(1) chopsticks[(self.num + 1) % 5].put(1)chopsticks = []philosophers = []#声明queue即筷子资源for x in range(0,phlioNum): chopsticks.append(queue.Queue(maxsize=1))for x in chopsticks: x.put(1)for x in range(0,phlioNum): philosophers.append(Philosopher(x))for x in philosophers: x.start() p.s. 持续撸中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-读者写者]]></title>
      <url>%2F2017%2F05%2F02%2Fprocess-reader-writer%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第二弹：读者写者问题 问题分析1.允许多个读进程进行读操作2.不允许读和写同时进行操作3.不允许多个读进程进行写操作读者和写者问题其实可以分为三种：读者优先 写者优先 公平竞争读者优先和公平竞争之间只差了一个信号量来对读写进程进行平等访问。读者优先可能造成写进程饿死，公平竞争的结果则是所有读进程结束后写进程才允许进行。而对与写者优先来说，读操作进行前需让出资源给写进程。 代码实现ps.condition.acquire() 与 condition.release() 间的通信尤为重要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#读者写者公平竞争import threadingfrom threading import Thread,Conditionimport timeimport randomglobal readcount,write,read,qc# 读者进程数readernum = 5# 读者数信号量计数readcount=0# 读者写者互斥访问write=0# 读者信号量read=0# 读者写者公平竞争信号量qc = 0rmutex=Condition()#readcount访问互斥wmutex=Condition()#读写互斥queue=Condition() #公平竞争class Reader(threading.Thread): """读者进程""" def __init__(self, num ): threading.Thread.__init__(self) self.num=num print('reader %s'%(num)) def run(self): global readcount,write,read,qc while True: queue.acquire() if qc==1: queue.wait() qc=1 rmutex.acquire() if read==1: rmutex.wait() read=1 if readcount==0 : wmutex.acquire() if write!=0: print('Reader want to read but writer is writing now!') wmutex.wait() print('Reader is notified by writer') wmutex.release() else: wmutex.release() readcount+=1 print("reader%s %s++"%(self.num,readcount)) read=0 rmutex.notify() rmutex.release() qc=0 queue.notify() queue.release() print("Reader%s is reading now!"%(self.num)) time.sleep(random.randint(1,5)) rmutex.acquire() if read==1: rmutex.wait() read=1 readcount-=1 print("reader%s %s--"%(self.num,readcount)) read=0 if readcount==0: wmutex.acquire() if(write==0): wmutex.notify() wmutex.release() else: wmutex.release() rmutex.notify() rmutex.release() print("Reader%s has finishied reading!"%(self.num))class Writer(threading.Thread): def run(self): global readcount,write,qc while True: queue.acquire() if qc==1: queue.wait() qc = 1 wmutex.acquire() if readcount!=0: print('Writer want to write but reader is reading now!') wmutex.wait() print("Writer is notified by readers!") write=1 print('Writer is writing now!') time.sleep(5) write=0 wmutex.notify() wmutex.release() qc=0 queue.notify() queue.release() print('Finished writing!')Writer().start()Readers = []# 创建读者5个进程for x in range(1,readernum): Readers.append(Reader(x))for x in Readers: x.start() p.s. 还有三个进程同步问题…持续中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程同步问题-生产者消费者]]></title>
      <url>%2F2017%2F04%2F23%2Fprocess-consumer-producer%2F</url>
      <content type="text"><![CDATA[操作系统进程同步问题第一弹：生产者消费者问题 问题分析操作系统中经典进程同步问题，生产者消费者问题。producer进程和consumer进程互斥访问资源1.无产品时，consumer阻塞2.产品数量最大时，producer阻塞 代码实现condition模块用于处理进程间通信 condition方法condition.accquire() –获得锁condition.wait() –阻塞等待condition.notify() –通知阻塞进程，退出阻塞condition.release() –释放锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import threadingimport timeimport randomproduct_max_num = 5product_pool = []class producer(threading.Thread): def __init__(self,cond,name): super(producer, self).__init__() self.cond = cond self.name = name def run(self): queue = range(5) global product_pool while True: self.cond.acquire() if len(product_pool)==product_max_num: print("product pool is full!") self.cond.wait() index = random.choice(queue) print("%s product %s" %(self.name,index)) product_pool.append(index) self.cond.notify() # if len(product_pool)&lt;product_max_num: # index = random.choice(queue) # print("%s product %s" %(self.name,index)) # product_pool.append(index) # self.cond.notify() # else: # print("product pool is full!") # self.cond.wait() self.cond.release() time.sleep(1)class consumer(threading.Thread): def __init__(self,cond,name): super(consumer, self).__init__() self.cond = cond self.name = name def run(self): global product_pool while True: self.cond.acquire() if len(product_pool) == 0: print("product pool is empty!") self.cond.wait() index = product_pool.pop(0) print("%s consume %s" %(self.name,index)) self.cond.notify() # if len(product_pool)&gt;0: # index = product_pool.pop(0) # print("%s consume %s" %(self.name,index)) # self.cond.notify() # else: # print("product pool is empty!") # self.cond.wait() self.cond.release() time.sleep(1)cond = threading.Condition()producer = producer(cond,'producer')consumer = consumer(cond,'consumer')producer.start()consumer.start()producer.join()consumer.join()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax实现图片上传]]></title>
      <url>%2F2017%2F03%2F25%2Fimg-upload%2F</url>
      <content type="text"><![CDATA[写项目的时候需要图片上传功能，这在web开发中也是比较普遍的功能。今天整理出一段时间关于图片上传的知识。一般上传图片的时候都需要图片预览，之后再提交，上传服务器。关于图片预览需要用到html5里的一些知识。 123&lt;!-- file类型的input，绑定uploadImg事件 --&gt;&lt;input type="file" name="上传图片" onchange="uploadImg(this)" &gt;&lt;img src="" id="img"&gt; 个人觉得ajax上传图片用户体验比较好，当然你也可以做成表单提交这里写了两个比较基本的判断，判断是否为图片格式和图片大小（最大为2M）。HTML5定义了FileReader作为文件API的重要成员用于读取文件，实现了图片预览。12345678910111213141516171819202122232425262728293031323334353637383940414243function uploadImg(source)&#123; var name = source.value; var file = source.files[0]; var fd = new FormData(); //正则判断上传文件格式 if(!/\.(gif|jpg|png|jpeg)$/.test(name))&#123; alert('上传的必须要是图片'); source.value=""; return ; &#125; //判断上传文件大小 if(file/1024&gt;2000)&#123; alert('上传的图片必须小于2m'); return ; &#125; //图片预览 if(window.FileReader)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; $('#img').attr('src',e.target.result) &#125; reader.readAsDataURL(file); &#125;else&#123; alert('browser not support!'); return ; &#125; fd.append("upfile",file); //ajax upload $.ajax(&#123; url:url, type:'POST', data:fd, //阻止序列化操作 processData:false, contentType:false, success:function(res)&#123; console.log('ok'); &#125;, error:function(res)&#123; console.log('no'); &#125; &#125;);&#125; 关于后端语言和框架的使用就看个人喜好了。反正我用的是php。上面是一个简单的单个图片上传，可能之后有时间会去做一下多图片的和可拖拽的…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[express下模板引擎共存]]></title>
      <url>%2F2017%2F03%2F24%2Fwindows-nodejs-express%2F</url>
      <content type="text"><![CDATA[最近在学nodejs下的express框架。Express中需要模板引擎来渲染模板文件，也就是我们平常说的html文件。在express工程中默认是jade视图引擎，但我想用html来写我的视图文件，需要ejs模板引擎，那如何让两种模板引擎共同存在。 cmd安装nodejs模块1npm install consolidate 1npm install express-hogan 在express的app.js中设置模板引擎1234567var engines = require('consolidate');app.engine('haml', engines.haml);app.engine('html', engines.hogan);app.set('view engine', 'jade');app.set('view engine', 'html'); 完成！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello]]></title>
      <url>%2F2017%2F03%2F24%2FHello%2F</url>
      <content type="text"><![CDATA[我的新博客又诞生了，第一次用静态博客感觉不错，以后会update。关于作者:123456789var I = &#123;Name: 致宇哥哥,Age: 21,School: BUCT,Major: CS,Home: Zhejiang,Phone: 13011136566,Email: 857188491@qq.com&#125;]]></content>
    </entry>

    
  
  
</search>
